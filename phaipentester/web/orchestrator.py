#!/usr/bin/env python3

import json
import requests
import asyncio
import websockets
import sys
import os
import re
import time
import shutil
import subprocess

# --------------------------------------------------------
# CONFIGURACIÓN
# --------------------------------------------------------

vRutaBaseOrchestrator = "/home/nipegun/HackingTools/PenTesterIA/web"
vRutaTools = os.path.join(vRutaBaseOrchestrator, "tools.txt")
vRutaSystemPrompt = os.path.join(vRutaBaseOrchestrator, "system-prompt.txt")
vRutaRequirements = os.path.join(vRutaBaseOrchestrator, "requirements.txt")

# URL de la API de IA - lee de variable de entorno o usa valor por defecto
vURLLlama = os.environ.get("PHIA_AI_API_URL", "http://127.0.0.1:9000/completion")
vWSMCP = "ws://127.0.0.1:9001"

vRutaBaseWorkspace = "/home/nipegun/pt-web-workspace"

# Globals de workspace
vWorkspace = None
vRutaLogs = None
vRutaEvidence = None
vRutaExploits = None
vRutaReport = None

vContadorAcciones = 0


# --------------------------------------------------------
# UTILIDADES DE FICHEROS Y NOMBRES
# --------------------------------------------------------

def fNormalizarNombre(vTexto):
  vTexto = vTexto.strip().lower()
  vTexto = re.sub(r"[^a-z0-9]+", "_", vTexto)
  vTexto = re.sub(r"_+", "_", vTexto)
  vTexto = vTexto.strip("_")
  if not vTexto:
    vTexto = "objetivo"
  return vTexto

def fAsegurarDirectorio(vRuta):
  if not os.path.exists(vRuta):
    os.makedirs(vRuta, exist_ok=True)

def fGuardarJSONEnArchivo(vRutaArchivo, vObjeto):
  with open(vRutaArchivo, "w") as f:
    json.dump(vObjeto, f, indent=2)

def fGuardarTextoEnArchivo(vRutaArchivo, vTexto):
  with open(vRutaArchivo, "w") as f:
    f.write(vTexto)


# --------------------------------------------------------
# VERIFICACIÓN DE DEPENDENCIAS
# --------------------------------------------------------

def fCargarRequirements():
  if not os.path.exists(vRutaRequirements):
    return []

  aPaquetes = []
  with open(vRutaRequirements, "r") as f:
    for vLinea in f:
      vLinea = vLinea.strip()
      if vLinea and not vLinea.startswith("#"):
        aPaquetes.append(vLinea)

  return aPaquetes

def fVerificarPaquete(vPaquete):
  # Primero intenta con 'which' (más rápido para binarios)
  if shutil.which(vPaquete):
    return True

  # Si no se encuentra con which, verifica con dpkg
  try:
    vResult = subprocess.run(
      ["dpkg", "-l", vPaquete],
      capture_output=True,
      text=True
    )
    # dpkg devuelve 0 si el paquete está instalado
    return vResult.returncode == 0
  except Exception:
    return False

def fVerificarDependencias():
  aPaquetes = fCargarRequirements()

  if not aPaquetes:
    return

  print("\n" + "="*60)
  print("VERIFICANDO DEPENDENCIAS DE PENTESTING")
  print("="*60)

  aInstalados = []
  aFaltantes = []

  for vPaq in aPaquetes:
    if fVerificarPaquete(vPaq):
      aInstalados.append(vPaq)
      print(f"✓ {vPaq:<20} [INSTALADO]")
    else:
      aFaltantes.append(vPaq)
      print(f"✗ {vPaq:<20} [NO ENCONTRADO]")

  print("="*60)
  print(f"Instalados: {len(aInstalados)}/{len(aPaquetes)}")

  if aFaltantes:
    print(f"\nPaquetes faltantes ({len(aFaltantes)}):")
    for vPaq in aFaltantes:
      print(f"  - {vPaq}")

    print("\nPara instalar los paquetes faltantes, ejecuta:")
    print(f"  sudo apt update && sudo apt install -y {' '.join(aFaltantes)}")

    vRespuesta = input("\n¿Deseas instalar los paquetes faltantes ahora? (s/N): ").strip().lower()

    if vRespuesta in ['s', 'si', 'y', 'yes']:
      print("\nInstalando paquetes...")
      try:
        vCmd = ["sudo", "apt", "install", "-y"] + aFaltantes
        vResult = subprocess.run(vCmd)

        if vResult.returncode == 0:
          print("\n✓ Paquetes instalados correctamente.")
        else:
          print("\n✗ Hubo un error durante la instalación.")
          print("  Puedes instalarlos manualmente más tarde.")
      except Exception as e:
        print(f"\n✗ Error al instalar: {e}")
        print("  Instálalos manualmente con:")
        print(f"  sudo apt install -y {' '.join(aFaltantes)}")
    else:
      print("\nPuedes instalarlos más tarde con el comando mostrado arriba.")
  else:
    print("\n✓ Todas las dependencias están instaladas.")

  print("="*60 + "\n")


# --------------------------------------------------------
# WORKSPACE
# --------------------------------------------------------

def fCrearWorkspace(vTarget):
  global vWorkspace, vRutaLogs, vRutaEvidence, vRutaExploits, vRutaReport

  vNombre = fNormalizarNombre(vTarget)
  vWorkspace = os.path.join(vRutaBaseWorkspace, vNombre)

  vRutaLogs = os.path.join(vWorkspace, "logs")
  vRutaEvidence = os.path.join(vWorkspace, "evidence")
  vRutaExploits = os.path.join(vWorkspace, "exploits")
  vRutaReport = os.path.join(vWorkspace, "report")

  fAsegurarDirectorio(vWorkspace)
  fAsegurarDirectorio(vRutaLogs)
  fAsegurarDirectorio(vRutaEvidence)
  fAsegurarDirectorio(vRutaExploits)
  fAsegurarDirectorio(vRutaReport)

  print(f"Workspace creado: {vWorkspace}")
  print(f"  Logs:      {vRutaLogs}")
  print(f"  Evidence:  {vRutaEvidence}")
  print(f"  Exploits:  {vRutaExploits}")
  print(f"  Report:    {vRutaReport}")


# --------------------------------------------------------
# CARGA DE TOOLS Y SYSTEM PROMPT
# --------------------------------------------------------

def fCargarTools():
  if not os.path.exists(vRutaTools):
    print(f"No encuentro {vRutaTools}")
    sys.exit(1)

  aTools = []
  vActual = {}

  with open(vRutaTools, "r") as f:
    for vLinea in f:
      vLinea = vLinea.strip()
      if not vLinea:
        if vActual:
          aTools.append(vActual)
          vActual = {}
        continue

      if vLinea.startswith("NAME="):
        vActual["name"] = vLinea.split("=",1)[1]
      elif vLinea.startswith("DESC="):
        vActual["desc"] = vLinea.split("=",1)[1]
      elif vLinea.startswith("ARGS="):
        vActual["args"] = vLinea.split("=",1)[1]

    if vActual:
      aTools.append(vActual)

  return aTools

def fCargarSystemPrompt():
  if not os.path.exists(vRutaSystemPrompt):
    print(f"No encuentro {vRutaSystemPrompt}")
    sys.exit(1)

  with open(vRutaSystemPrompt, "r") as f:
    return f.read()

def fConstruirPromptTotal(vSystemPromptBase, aTools):
  aLineas = []
  aLineas.append(vSystemPromptBase.strip())
  aLineas.append("\n\n=== HERRAMIENTAS MCP DISPONIBLES ===\n")

  for vTool in aTools:
    vNombre = vTool["name"]
    vDesc = vTool.get("desc", "Sin descripción")
    aArgs = vTool.get("args", "").split(",")

    aLineas.append(f"- {vNombre}")
    aLineas.append(f"  Descripción: {vDesc}")
    aLineas.append("  Uso (formato JSON):")
    aLineas.append("  {")
    aLineas.append(f'    "tool": "{vNombre}",')
    aLineas.append('    "arguments": {')
    for vArg in aArgs:
      vArg = vArg.strip()
      if vArg:
        aLineas.append(f'      "{vArg}": "VALOR",')
    aLineas.append("    }")
    aLineas.append("  }\n")

  aLineas.append("Cuando quieras usar una herramienta, devuelve SOLO el JSON exacto del tool-call.")
  aLineas.append("No expliques el comando, no des texto adicional, solo el JSON.")

  return "\n".join(aLineas)


# --------------------------------------------------------
# COMUNICACIÓN CON LLAMA.CPP
# --------------------------------------------------------

def fEnviarALlama(vPromptCompleto, vEntradaUsuario):
  vPromptFinal = vPromptCompleto + "\n\nUsuario:\n" + vEntradaUsuario + "\nAsistente:"

  vPayload = {
    "prompt": vPromptFinal,
    "temperature": 0.0,  # Más determinista
    "top_p": 0.9,
    "top_k": 40,
    "n_predict": 300,  # Reducido para respuestas más cortas
    "stop": ["\nUsuario:", "Usuario:", "\n\n"]  # Detener en estas cadenas
  }

  print(f"\n[DEBUG] Enviando petición a {vURLLlama}")
  print(f"[DEBUG] Longitud del prompt: {len(vPromptFinal)} caracteres")

  try:
    vResp = requests.post(vURLLlama, json=vPayload, timeout=120)
    vResp.raise_for_status()
    vJSON = vResp.json()

    print(f"[DEBUG] Respuesta recibida")

    # Ajusta esta parte según el formato real de la respuesta de tu llama.cpp.
    if "content" in vJSON:
      return vJSON["content"]
    else:
      # Fallback simple
      print(f"[DEBUG] Formato inesperado, campos disponibles: {vJSON.keys()}")
      return json.dumps(vJSON)

  except requests.exceptions.Timeout:
    print(f"[ERROR] Timeout al comunicarse con llama.cpp")
    return "ERROR: El modelo tardó demasiado en responder."
  except Exception as e:
    print(f"[ERROR] Error al comunicarse con llama.cpp: {e}")
    return f"ERROR: {str(e)}"


# --------------------------------------------------------
# COMUNICACIÓN CON MCP
# --------------------------------------------------------

async def fLlamarMCP(vTool, vArgs):
  async with websockets.connect(vWSMCP) as vWS:
    vMsg = {
      "jsonrpc": "2.0",
      "id": 1,
      "method": "tools/call",
      "params": {
        "tool": vTool,
        "arguments": vArgs
      }
    }
    await vWS.send(json.dumps(vMsg))
    vRespuesta = await vWS.recv()
    return json.loads(vRespuesta)


# --------------------------------------------------------
# DETECTAR TOOL-CALL DEL MODELO
# --------------------------------------------------------

def fDetectarToolCall(vTexto):
  """
  Detecta y extrae un tool-call JSON del texto del modelo.
  El JSON puede venir mezclado con texto adicional.
  """
  # Primero intenta parsear todo el texto como JSON
  try:
    vJSON = json.loads(vTexto.strip())
    if "tool" in vJSON and "arguments" in vJSON:
      return vJSON
  except Exception:
    pass

  # Buscar todas las posiciones donde aparece '{'
  vPosiciones = [i for i, c in enumerate(vTexto) if c == '{']

  # Para cada '{', intentar extraer un JSON válido
  for vInicio in vPosiciones:
    # Intentar encontrar el '}' correspondiente
    vContador = 0
    for vFin in range(vInicio, len(vTexto)):
      if vTexto[vFin] == '{':
        vContador += 1
      elif vTexto[vFin] == '}':
        vContador -= 1
        if vContador == 0:
          # Encontramos un par completo de llaves
          vJSONStr = vTexto[vInicio:vFin+1]
          try:
            vJSON = json.loads(vJSONStr)
            if isinstance(vJSON, dict) and "tool" in vJSON and "arguments" in vJSON:
              print(f"[DEBUG] Tool-call detectado: {vJSON['tool']}")
              print(f"[DEBUG] JSON extraído: {vJSONStr}")
              return vJSON
          except Exception:
            # Este fragmento no es JSON válido, continuar
            pass
          break

  print(f"[DEBUG] No se detectó tool-call válido en la respuesta")
  print(f"[DEBUG] Texto recibido: {vTexto[:200]}...")
  return None


# --------------------------------------------------------
# PROCESAR RESULTADO DE MCP (LOGS, EVIDENCIAS, INFORME)
# --------------------------------------------------------

def fGenerarNombreAccion(vTool):
  global vContadorAcciones
  vContadorAcciones += 1
  vTimestamp = int(time.time())
  vNombre = f"{vContadorAcciones:04d}_{fNormalizarNombre(vTool)}_{vTimestamp}"
  return vNombre

def fProcesarResultadoMCP(vTool, vArgs, vResultado):
  if vWorkspace is None:
    return

  vNombreAccion = fGenerarNombreAccion(vTool)

  # 1) Log general de tool-call (args + resultado bruto)
  vRutaLogJSON = os.path.join(vRutaLogs, f"{vNombreAccion}_toolcall.json")
  vObjetoLog = {
    "tool": vTool,
    "arguments": vArgs,
    "result": vResultado
  }
  fGuardarJSONEnArchivo(vRutaLogJSON, vObjetoLog)

  # 2) Si hay request/response HTTP, los guardamos como evidencias
  try:
    vResult = vResultado.get("result", {})
    vOutput = vResult.get("output", {})

    vRequest = vOutput.get("request")
    vResponse = vOutput.get("response")

    if vRequest:
      vRutaReq = os.path.join(vRutaEvidence, f"{vNombreAccion}_request.txt")
      fGuardarTextoEnArchivo(vRutaReq, vRequest)

    if vResponse:
      vRutaRes = os.path.join(vRutaEvidence, f"{vNombreAccion}_response.txt")
      if isinstance(vResponse, str):
        fGuardarTextoEnArchivo(vRutaRes, vResponse)
      else:
        fGuardarTextoEnArchivo(vRutaRes, json.dumps(vResponse, indent=2))

  except Exception:
    pass

  # 3) Opcional: si el MCP devuelve algo como "evidence" o "note", también lo guardamos
  try:
    vResult = vResultado.get("result", {})
    vEvidence = vResult.get("evidence")
    if vEvidence:
      vRutaEv = os.path.join(vRutaEvidence, f"{vNombreAccion}_extra.txt")
      if isinstance(vEvidence, str):
        fGuardarTextoEnArchivo(vRutaEv, vEvidence)
      else:
        fGuardarTextoEnArchivo(vRutaEv, json.dumps(vEvidence, indent=2))
  except Exception:
    pass


# --------------------------------------------------------
# MODO AUTOMÁTICO
# --------------------------------------------------------

async def fModoAutomatico(vTarget, vSystemPromptConObjetivo):
  """
  Ejecuta automáticamente una secuencia completa de pentesting
  """
  print("\n" + "="*70)
  print("MODO AUTOMÁTICO ACTIVADO")
  print("="*70)
  print("El framework ejecutará automáticamente:")
  print("  1. Reconocimiento inicial (HTTP GET)")
  print("  2. Escaneo de directorios")
  print("  3. Búsqueda de vulnerabilidades SQL Injection")
  print("  4. Búsqueda de vulnerabilidades XSS")
  print("  5. Generación de informe final")
  print("="*70 + "\n")

  aSecuenciaAcciones = [
    "Haz un HTTP GET al objetivo para obtener la página principal y analizar las cabeceras",
    "Escanea directorios y archivos comunes usando dirscan",
    "Analiza todos los parámetros encontrados en busca de SQL Injection",
    "Analiza todos los parámetros encontrados en busca de XSS",
    "Resume todos los hallazgos y genera el informe final en Markdown y HTML"
  ]

  for i, vAccion in enumerate(aSecuenciaAcciones, 1):
    print(f"\n{'='*70}")
    print(f"PASO {i}/{len(aSecuenciaAcciones)}: {vAccion}")
    print(f"{'='*70}\n")

    vSalida = fEnviarALlama(vSystemPromptConObjetivo, vAccion)
    vToolCall = fDetectarToolCall(vSalida)

    if vToolCall:
      vTool = vToolCall["tool"]
      vArgs = vToolCall["arguments"]

      # Añadir workspace si la tool lo necesita
      if "workspace" not in vArgs and vTool in ["dirscan", "report.write", "report.final_md", "report.final_html", "exploit.write_poc", "exploit.run"]:
        vArgs["workspace"] = vWorkspace

      print(f"[Orquestador] Ejecutando: {vTool}")
      print(f"[Orquestador] Argumentos: {vArgs}\n")

      vResultado = await fLlamarMCP(vTool, vArgs)
      fProcesarResultadoMCP(vTool, vArgs, vResultado)

      print("[Resultado MCP]:")
      print(json.dumps(vResultado, indent=2))

      # Analizar resultado
      vNuevoContexto = (
        f"Resultado de {vTool}:\n"
        f"{json.dumps(vResultado, indent=2)}\n"
        "Analiza este resultado brevemente."
      )
      vAnalisis = fEnviarALlama(vSystemPromptConObjetivo, vNuevoContexto)
      print(f"\n[Análisis]:\n{vAnalisis}\n")

    else:
      print(f"\n[Modelo]:\n{vSalida}\n")

    # Pausa entre acciones
    import time
    time.sleep(2)

  print("\n" + "="*70)
  print("PENTESTING AUTOMÁTICO COMPLETADO")
  print("="*70)
  print(f"\nResultados guardados en: {vWorkspace}")
  print(f"  - Logs:      {vRutaLogs}")
  print(f"  - Evidencia: {vRutaEvidence}")
  print(f"  - Reportes:  {vRutaReport}")
  print("="*70 + "\n")


# --------------------------------------------------------
# LOOP PRINCIPAL
# --------------------------------------------------------

async def fLoop():
  aTools = fCargarTools()
  vSystemPromptBase = fCargarSystemPrompt()
  vSystemPromptFinal = fConstruirPromptTotal(vSystemPromptBase, aTools)

  print("Orchestrator PT-Web avanzado inicializado.")
  print("Tools cargadas desde tools.txt:")
  for vT in aTools:
    print(f" - {vT['name']}")

  # Verificar dependencias del sistema
  fVerificarDependencias()

  vTarget = input("\nObjetivo (URL o dominio, por ejemplo https://ejemplo.com): ").strip()
  if not vTarget:
    print("Objetivo vacío. Saliendo.")
    return

  fCrearWorkspace(vTarget)

  # Agregar el objetivo al system prompt
  vSystemPromptConObjetivo = (
    vSystemPromptFinal +
    f"\n\n=== OBJETIVO ACTUAL ===\n"
    f"URL/Dominio: {vTarget}\n"
    f"Workspace: {vWorkspace}\n"
    f"\nEste es el objetivo que debes analizar. "
    f"Cuando el usuario te pida realizar acciones, úsalas contra este objetivo: {vTarget}\n"
    f"No pidas la URL nuevamente, ya la tienes: {vTarget}\n"
  )

  # Preguntar modo de operación
  print("\n" + "="*70)
  print("MODO DE OPERACIÓN")
  print("="*70)
  print("  [1] Modo Automático - El framework ejecuta todo el pentesting")
  print("  [2] Modo Manual     - Tú escribes los comandos")
  print("="*70)

  vModo = input("\nSelecciona modo [1/2] (por defecto: 1): ").strip()

  if vModo == "2":
    # Modo Manual
    print("\nModo Manual activado.")
    print("Escribe tus instrucciones de pentesting web.")
    print("Ejemplo: 'Haz reconocimiento inicial del objetivo.'\n")

    while True:
      vEntrada = input("\nNiPeGun-PTWeb> ")

      if not vEntrada:
        continue

      vSalida = fEnviarALlama(vSystemPromptConObjetivo, vEntrada)
      vToolCall = fDetectarToolCall(vSalida)

      if vToolCall:
        vTool = vToolCall["tool"]
        vArgs = vToolCall["arguments"]

        # Añadir workspace si la tool lo necesita
        if "workspace" not in vArgs and vTool in ["dirscan", "report.write", "report.final_md", "report.final_html", "exploit.write_poc", "exploit.run"]:
          vArgs["workspace"] = vWorkspace

        print(f"[Orquestador] El modelo pide tool: {vTool}")
        print(f"[Orquestador] Args: {vArgs}\n")

        vResultado = await fLlamarMCP(vTool, vArgs)

        fProcesarResultadoMCP(vTool, vArgs, vResultado)

        print("[Resultado MCP]:")
        print(json.dumps(vResultado, indent=2))

        vNuevoContexto = (
          f"Resultado de {vTool} contra el objetivo {vTarget}:\n"
          f"{json.dumps(vResultado, indent=2)}\n"
          "Analiza este resultado, identifica posibles vulnerabilidades, "
          "clasifícalas (OWASP, CWE, severidad) y decide el siguiente paso."
        )
        vContinuacion = fEnviarALlama(vSystemPromptConObjetivo, vNuevoContexto)

        print("\n[Modelo]:")
        print(vContinuacion)

      else:
        print("\n[Modelo]:")
        print(vSalida)

  else:
    # Modo Automático (por defecto)
    await fModoAutomatico(vTarget, vSystemPromptConObjetivo)


if __name__ == "__main__":
  try:
    asyncio.run(fLoop())
  except KeyboardInterrupt:
    sys.exit(0)
