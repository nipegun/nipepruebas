#!/usr/bin/env python3

import importlib
import subprocess
import sys

def fAsegurarPaqueteDebian(vModuloPython, vPaqueteDebian):
  try:
    importlib.import_module(vModuloPython)
  except ImportError:
    print(f"El módulo {vModuloPython} no está instalado. Instalando {vPaqueteDebian}...")
    vComando = ["sudo apt-get", "-y", "update"]
    subprocess.run(vComando, check=True)
    vComando = ["sudo apt-get", "-y", "install", vPaqueteDebian]
    subprocess.run(vComando, check=True)

fAsegurarPaqueteDebian("websockets", "python3-websockets")

import asyncio
import json
import websockets
import requests
import time
import os
import urllib.parse
import shutil
import shlex
import stat

# --------------------------------------------------------
# CONFIG
# --------------------------------------------------------

vHost = "127.0.0.1"
vPort = 9004 # Puertos: ad(9001), bt(9002), lan(9003), web(9004), wifi(9005)

# --------------------------------------------------------
# CMDHISTORY - Contador global
# --------------------------------------------------------

vCmdCounter = 0

# --------------------------------------------------------
# HELPERS GENERALES
# --------------------------------------------------------

def fHacerGET(vURL, vHeaders, vWorkspace=None):
  global vCmdCounter
  vHeaders = vHeaders or {}

  # Guardar cmdhistory
  if vWorkspace:
    vCmdHistoryDir = os.path.join(vWorkspace, "cmdhistory")
    os.makedirs(vCmdHistoryDir, exist_ok=True)
    vCmdCounter += 1
    vNumStr = str(vCmdCounter).zfill(3)

    # Guardar comando (input)
    vReqStr = f"GET {vURL}\nHEADERS:\n{json.dumps(vHeaders, indent=2)}"
    vInFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-in.txt")
    with open(vInFile, "w") as f:
      f.write(vReqStr)
  else:
    vReqStr = f"GET {vURL}\nHEADERS:\n{json.dumps(vHeaders, indent=2)}"

  vResp = requests.get(vURL, headers=vHeaders, verify=False)
  vResStr = (
    f"STATUS: {vResp.status_code}\n"
    f"HEADERS:\n{json.dumps(dict(vResp.headers), indent=2)}\n\n"
    f"BODY:\n{vResp.text}"
  )

  # Guardar salida (output)
  if vWorkspace:
    vOutFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-out.txt")
    with open(vOutFile, "w") as f:
      f.write(vResStr)

  return vReqStr, vResStr

def fHacerPOST(vURL, vData, vHeaders, vWorkspace=None):
  global vCmdCounter
  vHeaders = vHeaders or {}
  vData = vData or {}

  # Guardar cmdhistory
  if vWorkspace:
    vCmdHistoryDir = os.path.join(vWorkspace, "cmdhistory")
    os.makedirs(vCmdHistoryDir, exist_ok=True)
    vCmdCounter += 1
    vNumStr = str(vCmdCounter).zfill(3)

    # Guardar comando (input)
    vReqStr = (
      f"POST {vURL}\n"
      f"HEADERS:\n{json.dumps(vHeaders, indent=2)}\n"
      f"DATA:\n{json.dumps(vData, indent=2)}"
    )
    vInFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-in.txt")
    with open(vInFile, "w") as f:
      f.write(vReqStr)
  else:
    vReqStr = (
      f"POST {vURL}\n"
      f"HEADERS:\n{json.dumps(vHeaders, indent=2)}\n"
      f"DATA:\n{json.dumps(vData, indent=2)}"
    )

  vResp = requests.post(vURL, headers=vHeaders, data=vData, verify=False)
  vResStr = (
    f"STATUS: {vResp.status_code}\n"
    f"HEADERS:\n{json.dumps(dict(vResp.headers), indent=2)}\n\n"
    f"BODY:\n{vResp.text}"
  )

  # Guardar salida (output)
  if vWorkspace:
    vOutFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-out.txt")
    with open(vOutFile, "w") as f:
      f.write(vResStr)

  return vReqStr, vResStr

def fEjecutarComando(vCmd, vWorkspace=None):
  global vCmdCounter
  try:
    # Si tenemos workspace, crear cmdhistory ahí; si no, en carpeta del framework
    if vWorkspace:
      vCmdHistoryDir = os.path.join(vWorkspace, "cmdhistory")
    else:
      vCmdHistoryDir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "cmdhistory")

    os.makedirs(vCmdHistoryDir, exist_ok=True)

    # Incrementar contador
    vCmdCounter += 1
    vNumStr = str(vCmdCounter).zfill(3)

    # Guardar comando (input)
    vInFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-in.txt")
    with open(vInFile, "w") as f:
      f.write(vCmd)

    v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
    vSalida = v.stdout + "\n" + v.stderr

    # Guardar salida (output)
    vOutFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-out.txt")
    with open(vOutFile, "w") as f:
      f.write(vSalida)

    return vSalida
  except Exception as e:
    return str(e)


# --------------------------------------------------------
# DIRSCAN
# --------------------------------------------------------

def fDirScan(vURL, vWordlist, vWorkspace):
  aResultados = []
  vCmd = None

  if shutil.which("gobuster"):
    vCmd = f"gobuster dir -u {shlex.quote(vURL)} -w {shlex.quote(vWordlist)} -q"
  elif shutil.which("dirsearch"):
    vSalidaFile = os.path.join(vWorkspace, "evidence", f"dirsearch_{int(time.time())}.txt")
    vCmd = (
      f"dirsearch -u {shlex.quote(vURL)} -w {shlex.quote(vWordlist)} "
      f"--simple-output {shlex.quote(vSalidaFile)}"
    )
  else:
    return ["ERROR: No gobuster ni dirsearch instalados."]

  vSalida = fEjecutarComando(vCmd, vWorkspace)

  vRuta = os.path.join(vWorkspace, "evidence", f"dirscan_{int(time.time())}.txt")
  os.makedirs(os.path.dirname(vRuta), exist_ok=True)
  with open(vRuta, "w") as f:
    f.write(vSalida)

  for vLinea in vSalida.splitlines():
    if "/" in vLinea:
      aResultados.append(vLinea.strip())

  return aResultados


# --------------------------------------------------------
# SQLI SCAN BÁSICO
# --------------------------------------------------------

def fSqliScan(vURL, vParam, vWorkspace=None):
  global vCmdCounter
  aPayloads = [
    "'",
    '"',
    "1'",
    "1\"",
    "\") or 1=1-- ",
    "') or 1=1-- ",
    "' or '1'='1"
  ]

  vParsed = urllib.parse.urlparse(vURL)
  vQS = urllib.parse.parse_qs(vParsed.query)

  if vParam not in vQS:
    return {"error": "El parámetro no está en la URL"}

  # Preparar cmdhistory si hay workspace
  if vWorkspace:
    vCmdHistoryDir = os.path.join(vWorkspace, "cmdhistory")
    os.makedirs(vCmdHistoryDir, exist_ok=True)

  aHallazgos = []

  for vP in aPayloads:
    vQS2 = dict(vQS)
    vQS2[vParam] = vP
    vQS2Encoded = urllib.parse.urlencode(vQS2, doseq=True)

    vNewURL = f"{vParsed.scheme}://{vParsed.netloc}{vParsed.path}?{vQS2Encoded}"

    # Guardar cmdhistory
    if vWorkspace:
      vCmdCounter += 1
      vNumStr = str(vCmdCounter).zfill(3)
      vReqStr = f"SQLI SCAN - GET {vNewURL}\nPayload: {vP}\nParam: {vParam}"
      vInFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-in.txt")
      with open(vInFile, "w") as f:
        f.write(vReqStr)

    vResp = requests.get(vNewURL, verify=False)
    vBody = vResp.text.lower()

    vResStr = f"STATUS: {vResp.status_code}\nBODY (primeros 1000 chars):\n{vResp.text[:1000]}"

    # Guardar salida
    if vWorkspace:
      vOutFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-out.txt")
      with open(vOutFile, "w") as f:
        f.write(vResStr)

    if "sql" in vBody or "syntax" in vBody or "mysql" in vBody or "error" in vBody:
      aHallazgos.append({
        "payload": vP,
        "url": vNewURL,
        "evidence": "error SQL detectado en respuesta"
      })

  return aHallazgos


# --------------------------------------------------------
# XSS SCAN BÁSICO
# --------------------------------------------------------

def fXssScan(vURL, vParam, vWorkspace=None):
  global vCmdCounter
  aPayloads = [
    "<script>alert(1)</script>",
    "\"><script>alert(1)</script>",
    "'><svg/onload=alert(1)>"
  ]

  vParsed = urllib.parse.urlparse(vURL)
  vQS = urllib.parse.parse_qs(vParsed.query)

  if vParam not in vQS:
    return {"error": "El parámetro no existe en la URL"}

  # Preparar cmdhistory si hay workspace
  if vWorkspace:
    vCmdHistoryDir = os.path.join(vWorkspace, "cmdhistory")
    os.makedirs(vCmdHistoryDir, exist_ok=True)

  aHallazgos = []

  for vP in aPayloads:
    vQS2 = dict(vQS)
    vQS2[vParam] = vP
    vEncoded = urllib.parse.urlencode(vQS2, doseq=True)
    vNewURL = f"{vParsed.scheme}://{vParsed.netloc}{vParsed.path}?{vEncoded}"

    # Guardar cmdhistory
    if vWorkspace:
      vCmdCounter += 1
      vNumStr = str(vCmdCounter).zfill(3)
      vReqStr = f"XSS SCAN - GET {vNewURL}\nPayload: {vP}\nParam: {vParam}"
      vInFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-in.txt")
      with open(vInFile, "w") as f:
        f.write(vReqStr)

    vResp = requests.get(vNewURL, verify=False)

    vResStr = f"STATUS: {vResp.status_code}\nBODY (primeros 1000 chars):\n{vResp.text[:1000]}"

    # Guardar salida
    if vWorkspace:
      vOutFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-out.txt")
      with open(vOutFile, "w") as f:
        f.write(vResStr)

    if vP.lower() in vResp.text.lower():
      aHallazgos.append({
        "payload": vP,
        "url": vNewURL,
        "evidence": "payload reflejado en respuesta"
      })

  return aHallazgos


# --------------------------------------------------------
# REPORT.WRITE / FINAL_MD / FINAL_HTML
# --------------------------------------------------------

def fReportWrite(vWorkspace, vSection, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  vLinea = f"\n=== {vSection} ===\n{vContent}\n"
  with open(vReportFile, "a") as f:
    f.write(vLinea)
  return {"status": "ok", "written": vLinea}

def fFindingReport(vWorkspace, vTitle, vSeverity, vDescription, vEvidence, vRecommendation):
  """
  Reporta un hallazgo estructurado en findings.txt

  Args:
    vWorkspace: Ruta al workspace
    vTitle: Título del hallazgo
    vSeverity: Severidad (Critical, High, Medium, Low, Info)
    vDescription: Descripción del hallazgo
    vEvidence: Evidencia técnica
    vRecommendation: Recomendación de remediación
  """
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)

  vTimestamp = time.strftime('%Y-%m-%d %H:%M:%S')
  vSeverity = vSeverity or "Info"
  vDescription = vDescription or "Sin descripción"
  vEvidence = vEvidence or "Sin evidencia"
  vRecommendation = vRecommendation or "Sin recomendación"

  vFinding = f"""
{'='*70}
[HALLAZGO] {vTitle}
{'='*70}
Fecha/Hora: {vTimestamp}
Severidad:  {vSeverity}

DESCRIPCIÓN:
{vDescription}

EVIDENCIA:
{vEvidence}

RECOMENDACIÓN:
{vRecommendation}
{'='*70}

"""

  with open(vReportFile, "a") as f:
    f.write(vFinding)

  return {
    "status": "ok",
    "message": "Hallazgo reportado exitosamente",
    "severity": vSeverity,
    "title": vTitle,
    "file": vReportFile
  }

def fReportFinalMD(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.md")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}

def fReportFinalHTML(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.html")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}


# --------------------------------------------------------
# EXPLOIT: WRITE_POC / RUN
# --------------------------------------------------------

def fExploitWritePoC(vWorkspace, vFilename, vContent):
  vFilename = os.path.basename(vFilename)
  if not vFilename:
    vFilename = f"poc_{int(time.time())}.py"

  vRutaExpl = os.path.join(vWorkspace, "exploits")
  os.makedirs(vRutaExpl, exist_ok=True)

  vRuta = os.path.join(vRutaExpl, vFilename)
  with open(vRuta, "w") as f:
    f.write(vContent)

  vModo = os.stat(vRuta).st_mode
  os.chmod(vRuta, vModo | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

  return {"status": "ok", "path": vRuta}

def fExploitRun(vWorkspace, vFilename, vArgs):
  vFilename = os.path.basename(vFilename)
  vRutaExpl = os.path.join(vWorkspace, "exploits")
  vRuta = os.path.join(vRutaExpl, vFilename)

  if not os.path.exists(vRuta):
    return {"error": f"Exploit no encontrado: {vRuta}"}

  vArgs = vArgs or ""
  vCmd = f"{shlex.quote(vRuta)} {vArgs}"

  # Usar fEjecutarComando para guardar en cmdhistory
  vSalida = fEjecutarComando(vCmd, vWorkspace)

  return {
    "command": vCmd,
    "output": vSalida
  }


# --------------------------------------------------------
# MANEJO DE SOLICITUDES MCP
# --------------------------------------------------------

async def fHandle(vWS):
  print(f"[MCP] Nueva conexión establecida desde {vWS.remote_address}")

  async for vMensaje in vWS:
    vJSON = json.loads(vMensaje)
    vMethod = vJSON.get("method")
    vID = vJSON.get("id")

    print(f"[MCP] Petición recibida: {vMethod}")

    if vMethod == "tools/list":
      vRespuesta = {
        "jsonrpc": "2.0",
        "id": vID,
        "result": {
          "tools": [
            {"name": "http.get"},
            {"name": "http.post"},
            {"name": "dirscan"},
            {"name": "sqli.scan"},
            {"name": "xss.scan"},
            {"name": "finding.report"},
            {"name": "report.write"},
            {"name": "report.final_md"},
            {"name": "report.final_html"},
            {"name": "exploit.write_poc"},
            {"name": "exploit.run"}
          ]
        }
      }
      await vWS.send(json.dumps(vRespuesta, ensure_ascii=False))
      continue

    if vMethod == "tools/call":
      vTool = vJSON["params"]["tool"]
      vArgs = vJSON["params"]["arguments"]

      print(f"[MCP] Ejecutando herramienta: {vTool}")

      if vTool == "http.get":
        vReq, vRes = fHacerGET(vArgs["url"], vArgs.get("headers"), vArgs.get("workspace"))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {
            "output": {
              "request": vReq,
              "response": vRes
            }
          }
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "http.post":
        vReq, vRes = fHacerPOST(vArgs["url"], vArgs.get("data"), vArgs.get("headers"), vArgs.get("workspace"))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {
            "output": {
              "request": vReq,
              "response": vRes
            }
          }
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "dirscan":
        vResultados = fDirScan(
          vArgs["url"],
          vArgs.get("wordlist", "/usr/share/wordlists/dirb/common.txt"),
          vArgs["workspace"]
        )
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vResultados}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "sqli.scan":
        vRes = fSqliScan(vArgs["url"], vArgs["param"], vArgs.get("workspace"))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "xss.scan":
        vRes = fXssScan(vArgs["url"], vArgs["param"], vArgs.get("workspace"))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "finding.report":
        vRes = fFindingReport(
          vArgs["workspace"],
          vArgs["title"],
          vArgs.get("severity", "Info"),
          vArgs.get("description", ""),
          vArgs.get("evidence", ""),
          vArgs.get("recommendation", "")
        )
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "report.write":
        vRes = fReportWrite(vArgs["workspace"], vArgs["section"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "report.final_md":
        vRes = fReportFinalMD(vArgs["workspace"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "report.final_html":
        vRes = fReportFinalHTML(vArgs["workspace"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "exploit.write_poc":
        vRes = fExploitWritePoC(vArgs["workspace"], vArgs["filename"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "exploit.run":
        vRes = fExploitRun(vArgs["workspace"], vArgs["filename"], vArgs.get("args", ""))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue


# --------------------------------------------------------
# MAIN SERVER
# --------------------------------------------------------

async def main():
  print(f"\n{'='*60}")
  print(f"MCP Web Pentesting Server")
  print(f"{'='*60}")
  print(f"Escuchando en: ws://{vHost}:{vPort}")
  print(f"Herramientas disponibles: 10")
  print(f"Estado: ACTIVO")
  print(f"{'='*60}\n")
  print("Esperando conexiones...\n")

  async with websockets.serve(fHandle, vHost, vPort):
    await asyncio.Future()

if __name__ == "__main__":
  asyncio.run(main())
