#!/usr/bin/env python3

import importlib
import subprocess
import sys

def fAsegurarPaqueteDebian(vModuloPython, vPaqueteDebian):
  try:
    importlib.import_module(vModuloPython)
  except ImportError:
    print(f"El módulo {vModuloPython} no está instalado. Instalando {vPaqueteDebian}...")
    vComando = ["sudo apt-get", "-y", "update"]
    subprocess.run(vComando, check=True)
    vComando = ["sudo apt-get", "-y", "install", vPaqueteDebian]
    subprocess.run(vComando, check=True)

fAsegurarPaqueteDebian("websockets", "python3-websockets")

import asyncio
import json
import websockets
import requests
import time
import os
import urllib.parse
import shutil
import shlex
import stat

# --------------------------------------------------------
# CONFIG
# --------------------------------------------------------

vHost = "127.0.0.1"
vPort = 9001


# --------------------------------------------------------
# HELPERS GENERALES
# --------------------------------------------------------

def fHacerGET(vURL, vHeaders):
  vHeaders = vHeaders or {}
  vReqStr = f"GET {vURL}\nHEADERS:\n{json.dumps(vHeaders, indent=2)}"

  vResp = requests.get(vURL, headers=vHeaders, verify=False)
  vResStr = (
    f"STATUS: {vResp.status_code}\n"
    f"HEADERS:\n{json.dumps(dict(vResp.headers), indent=2)}\n\n"
    f"BODY:\n{vResp.text}"
  )
  return vReqStr, vResStr

def fHacerPOST(vURL, vData, vHeaders):
  vHeaders = vHeaders or {}
  vData = vData or {}
  vReqStr = (
    f"POST {vURL}\n"
    f"HEADERS:\n{json.dumps(vHeaders, indent=2)}\n"
    f"DATA:\n{json.dumps(vData, indent=2)}"
  )

  vResp = requests.post(vURL, headers=vHeaders, data=vData, verify=False)
  vResStr = (
    f"STATUS: {vResp.status_code}\n"
    f"HEADERS:\n{json.dumps(dict(vResp.headers), indent=2)}\n\n"
    f"BODY:\n{vResp.text}"
  )
  return vReqStr, vResStr

def fEjecutarComando(vCmd):
  try:
    v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
    return v.stdout + "\n" + v.stderr
  except Exception as e:
    return str(e)


# --------------------------------------------------------
# DIRSCAN
# --------------------------------------------------------

def fDirScan(vURL, vWordlist, vWorkspace):
  aResultados = []
  vCmd = None

  if shutil.which("gobuster"):
    vCmd = f"gobuster dir -u {shlex.quote(vURL)} -w {shlex.quote(vWordlist)} -q"
  elif shutil.which("dirsearch"):
    vSalidaFile = os.path.join(vWorkspace, "evidence", f"dirsearch_{int(time.time())}.txt")
    vCmd = (
      f"dirsearch -u {shlex.quote(vURL)} -w {shlex.quote(vWordlist)} "
      f"--simple-output {shlex.quote(vSalidaFile)}"
    )
  else:
    return ["ERROR: No gobuster ni dirsearch instalados."]

  vSalida = fEjecutarComando(vCmd)

  vRuta = os.path.join(vWorkspace, "evidence", f"dirscan_{int(time.time())}.txt")
  os.makedirs(os.path.dirname(vRuta), exist_ok=True)
  with open(vRuta, "w") as f:
    f.write(vSalida)

  for vLinea in vSalida.splitlines():
    if "/" in vLinea:
      aResultados.append(vLinea.strip())

  return aResultados


# --------------------------------------------------------
# SQLI SCAN BÁSICO
# --------------------------------------------------------

def fSqliScan(vURL, vParam):
  aPayloads = [
    "'",
    '"',
    "1'",
    "1\"",
    "\") or 1=1-- ",
    "') or 1=1-- ",
    "' or '1'='1"
  ]

  vParsed = urllib.parse.urlparse(vURL)
  vQS = urllib.parse.parse_qs(vParsed.query)

  if vParam not in vQS:
    return {"error": "El parámetro no está en la URL"}

  aHallazgos = []

  for vP in aPayloads:
    vQS2 = dict(vQS)
    vQS2[vParam] = vP
    vQS2Encoded = urllib.parse.urlencode(vQS2, doseq=True)

    vNewURL = f"{vParsed.scheme}://{vParsed.netloc}{vParsed.path}?{vQS2Encoded}"
    vResp = requests.get(vNewURL, verify=False)
    vBody = vResp.text.lower()

    if "sql" in vBody or "syntax" in vBody or "mysql" in vBody or "error" in vBody:
      aHallazgos.append({
        "payload": vP,
        "url": vNewURL,
        "evidence": "error SQL detectado en respuesta"
      })

  return aHallazgos


# --------------------------------------------------------
# XSS SCAN BÁSICO
# --------------------------------------------------------

def fXssScan(vURL, vParam):
  aPayloads = [
    "<script>alert(1)</script>",
    "\"><script>alert(1)</script>",
    "'><svg/onload=alert(1)>"
  ]

  vParsed = urllib.parse.urlparse(vURL)
  vQS = urllib.parse.parse_qs(vParsed.query)

  if vParam not in vQS:
    return {"error": "El parámetro no existe en la URL"}

  aHallazgos = []

  for vP in aPayloads:
    vQS2 = dict(vQS)
    vQS2[vParam] = vP
    vEncoded = urllib.parse.urlencode(vQS2, doseq=True)
    vNewURL = f"{vParsed.scheme}://{vParsed.netloc}{vParsed.path}?{vEncoded}"

    vResp = requests.get(vNewURL, verify=False)
    if vP.lower() in vResp.text.lower():
      aHallazgos.append({
        "payload": vP,
        "url": vNewURL,
        "evidence": "payload reflejado en respuesta"
      })

  return aHallazgos


# --------------------------------------------------------
# REPORT.WRITE / FINAL_MD / FINAL_HTML
# --------------------------------------------------------

def fReportWrite(vWorkspace, vSection, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  vLinea = f"\n=== {vSection} ===\n{vContent}\n"
  with open(vReportFile, "a") as f:
    f.write(vLinea)
  return {"status": "ok", "written": vLinea}

def fReportFinalMD(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.md")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}

def fReportFinalHTML(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.html")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}


# --------------------------------------------------------
# EXPLOIT: WRITE_POC / RUN
# --------------------------------------------------------

def fExploitWritePoC(vWorkspace, vFilename, vContent):
  vFilename = os.path.basename(vFilename)
  if not vFilename:
    vFilename = f"poc_{int(time.time())}.py"

  vRutaExpl = os.path.join(vWorkspace, "exploits")
  os.makedirs(vRutaExpl, exist_ok=True)

  vRuta = os.path.join(vRutaExpl, vFilename)
  with open(vRuta, "w") as f:
    f.write(vContent)

  vModo = os.stat(vRuta).st_mode
  os.chmod(vRuta, vModo | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

  return {"status": "ok", "path": vRuta}

def fExploitRun(vWorkspace, vFilename, vArgs):
  vFilename = os.path.basename(vFilename)
  vRutaExpl = os.path.join(vWorkspace, "exploits")
  vRuta = os.path.join(vRutaExpl, vFilename)

  if not os.path.exists(vRuta):
    return {"error": f"Exploit no encontrado: {vRuta}"}

  vArgs = vArgs or ""
  vCmd = f"{shlex.quote(vRuta)} {vArgs}"

  v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
  return {
    "command": vCmd,
    "stdout": v.stdout,
    "stderr": v.stderr,
    "returncode": v.returncode
  }


# --------------------------------------------------------
# MANEJO DE SOLICITUDES MCP
# --------------------------------------------------------

async def fHandle(vWS):
  print(f"[MCP] Nueva conexión establecida desde {vWS.remote_address}")

  async for vMensaje in vWS:
    vJSON = json.loads(vMensaje)
    vMethod = vJSON.get("method")
    vID = vJSON.get("id")

    print(f"[MCP] Petición recibida: {vMethod}")

    if vMethod == "tools/list":
      vRespuesta = {
        "jsonrpc": "2.0",
        "id": vID,
        "result": {
          "tools": [
            {"name": "http.get"},
            {"name": "http.post"},
            {"name": "dirscan"},
            {"name": "sqli.scan"},
            {"name": "xss.scan"},
            {"name": "report.write"},
            {"name": "report.final_md"},
            {"name": "report.final_html"},
            {"name": "exploit.write_poc"},
            {"name": "exploit.run"}
          ]
        }
      }
      await vWS.send(json.dumps(vRespuesta))
      continue

    if vMethod == "tools/call":
      vTool = vJSON["params"]["tool"]
      vArgs = vJSON["params"]["arguments"]

      print(f"[MCP] Ejecutando herramienta: {vTool}")

      if vTool == "http.get":
        vReq, vRes = fHacerGET(vArgs["url"], vArgs.get("headers"))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {
            "output": {
              "request": vReq,
              "response": vRes
            }
          }
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "http.post":
        vReq, vRes = fHacerPOST(vArgs["url"], vArgs.get("data"), vArgs.get("headers"))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {
            "output": {
              "request": vReq,
              "response": vRes
            }
          }
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "dirscan":
        vResultados = fDirScan(
          vArgs["url"],
          vArgs.get("wordlist", "/usr/share/wordlists/dirb/common.txt"),
          vArgs["workspace"]
        )
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vResultados}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "sqli.scan":
        vRes = fSqliScan(vArgs["url"], vArgs["param"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "xss.scan":
        vRes = fXssScan(vArgs["url"], vArgs["param"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "report.write":
        vRes = fReportWrite(vArgs["workspace"], vArgs["section"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "report.final_md":
        vRes = fReportFinalMD(vArgs["workspace"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "report.final_html":
        vRes = fReportFinalHTML(vArgs["workspace"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "exploit.write_poc":
        vRes = fExploitWritePoC(vArgs["workspace"], vArgs["filename"], vArgs["content"])
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue

      if vTool == "exploit.run":
        vRes = fExploitRun(vArgs["workspace"], vArgs["filename"], vArgs.get("args", ""))
        vRespuesta = {
          "jsonrpc": "2.0",
          "id": vID,
          "result": {"output": vRes}
        }
        await vWS.send(json.dumps(vRespuesta))
        continue


# --------------------------------------------------------
# MAIN SERVER
# --------------------------------------------------------

async def main():
  print(f"\n{'='*60}")
  print(f"MCP Web Pentesting Server")
  print(f"{'='*60}")
  print(f"Escuchando en: ws://{vHost}:{vPort}")
  print(f"Herramientas disponibles: 10")
  print(f"Estado: ACTIVO")
  print(f"{'='*60}\n")
  print("Esperando conexiones...\n")

  async with websockets.serve(fHandle, vHost, vPort):
    await asyncio.Future()

if __name__ == "__main__":
  asyncio.run(main())
