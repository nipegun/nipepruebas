#!/usr/bin/env python3

import importlib
import subprocess
import sys
import asyncio
import json
import websockets
import time
import os
import shutil
import shlex
import stat

# Asegurar dependencias de sistema (básicas)
def fAsegurarPaqueteDebian(vModuloPython, vPaqueteDebian):
  try:
    if vModuloPython:
      importlib.import_module(vModuloPython)
  except ImportError:
    pass # Se instala abajo si falta

# Checkeo básico de paquetes (python libs ya están en requirements, aquí check de sistema si queremos automaticidad)
# En este caso asumimos entorno preparado o que el usuario instalará lo que falte.

# --------------------------------------------------------
# CONFIG
# --------------------------------------------------------

vHost = "127.0.0.1"
vPort = 9002  # Puerto diferente al web (9001)

# --------------------------------------------------------
# HELPERS GENERALES
# --------------------------------------------------------

def fEjecutarComando(vCmd):
  try:
    print(f"[CMD] Ejecutando: {vCmd}")
    v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
    return v.stdout + "\n" + v.stderr
  except Exception as e:
    return str(e)

def fAsegurarHerramienta(vNombre):
  if not shutil.which(vNombre):
    return False
  return True

# --------------------------------------------------------
# HERRAMIENTAS DE RED
# --------------------------------------------------------

def fPortScan(vTarget, vPorts, vScanType, vWorkspace):
  if not fAsegurarHerramienta("nmap"):
    return "ERROR: nmap no encontrado. Instala nmap."

  vSalidaFile = os.path.join(vWorkspace, "evidence", f"nmap_scan_{int(time.time())}.txt")
  os.makedirs(os.path.dirname(vSalidaFile), exist_ok=True)
  
  # Construir comando nmap
  # Por seguridad, limitamos argumentos
  vScanType = vScanType or "-sS"
  vPorts = vPorts or "1-1000"
  
  vCmd = f"nmap {vScanType} -p {shlex.quote(vPorts)} -oN {shlex.quote(vSalidaFile)} {shlex.quote(vTarget)}"
  
  vSalida = fEjecutarComando(vCmd)
  return vSalida

def fServiceEnum(vTarget, vPorts, vWorkspace):
  if not fAsegurarHerramienta("nmap"):
    return "ERROR: nmap no encontrado."

  vSalidaFile = os.path.join(vWorkspace, "evidence", f"nmap_services_{int(time.time())}.txt")
  os.makedirs(os.path.dirname(vSalidaFile), exist_ok=True)

  vPorts = vPorts or "top-ports 100"
  
  # Scaneo de versiones (-sV) y scripts por defecto (-sC)
  vCmd = f"nmap -sV -sC -p {shlex.quote(vPorts)} -oN {shlex.quote(vSalidaFile)} {shlex.quote(vTarget)}"
  
  vSalida = fEjecutarComando(vCmd)
  return vSalida

def fVulnScan(vTarget, vWorkspace):
  if not fAsegurarHerramienta("nmap"):
    return "ERROR: nmap no encontrado."
  
  vSalidaFile = os.path.join(vWorkspace, "evidence", f"nmap_vuln_{int(time.time())}.txt")
  # Usa script vuln
  vCmd = f"nmap --script vuln -oN {shlex.quote(vSalidaFile)} {shlex.quote(vTarget)}"
  
  vSalida = fEjecutarComando(vCmd)
  return vSalida

def fNetworkSniff(vInterface, vCount, vFilter, vWorkspace):
  if not fAsegurarHerramienta("tcpdump"):
    return "ERROR: tcpdump no encontrado."
  
  vSalidaFile = os.path.join(vWorkspace, "evidence", f"sniff_{int(time.time())}.pcap")
  os.makedirs(os.path.dirname(vSalidaFile), exist_ok=True)
  
  vCount = vCount or "100"
  vFilter = vFilter or ""
  
  # Necesita sudo normalmente. Asumimos que el usuario corre el script con permisos o tcpdump tiene capabilities.
  # Si falla por permisos, retornará error.
  vCmd = f"sudo timeout 30 tcpdump -i {shlex.quote(vInterface)} -c {shlex.quote(vCount)} -w {shlex.quote(vSalidaFile)} {vFilter}"
  
  vSalida = fEjecutarComando(vCmd)
  return f"Captura finalizada. Salida: {vSalida}\nArchivo guardado en: {vSalidaFile}"


# --------------------------------------------------------
# REPORT / EXPLOIT (Reutilizados del web framework)
# --------------------------------------------------------

def fReportWrite(vWorkspace, vSection, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  vLinea = f"\n=== {vSection} ===\n{vContent}\n"
  with open(vReportFile, "a") as f:
    f.write(vLinea)
  return {"status": "ok", "written": vLinea}

def fReportFinalMD(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.md")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}

def fReportFinalHTML(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.html")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}

def fExploitWritePoC(vWorkspace, vFilename, vContent):
  vFilename = os.path.basename(vFilename)
  if not vFilename:
    vFilename = f"poc_{int(time.time())}.py"

  vRutaExpl = os.path.join(vWorkspace, "exploits")
  os.makedirs(vRutaExpl, exist_ok=True)

  vRuta = os.path.join(vRutaExpl, vFilename)
  with open(vRuta, "w") as f:
    f.write(vContent)

  vModo = os.stat(vRuta).st_mode
  os.chmod(vRuta, vModo | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

  return {"status": "ok", "path": vRuta}

def fExploitRun(vWorkspace, vFilename, vArgs):
  vFilename = os.path.basename(vFilename)
  vRutaExpl = os.path.join(vWorkspace, "exploits")
  vRuta = os.path.join(vRutaExpl, vFilename)

  if not os.path.exists(vRuta):
    return {"error": f"Exploit no encontrado: {vRuta}"}

  vArgs = vArgs or ""
  vCmd = f"{shlex.quote(vRuta)} {vArgs}"

  v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
  return {
    "command": vCmd,
    "stdout": v.stdout,
    "stderr": v.stderr,
    "returncode": v.returncode
  }


# --------------------------------------------------------
# MANEJO DE SOLICITUDES MCP
# --------------------------------------------------------

async def fHandle(vWS):
  print(f"[MCP] Nueva conexión establecida desde {vWS.remote_address}")

  try:
    async for vMensaje in vWS:
      try:
        vJSON = json.loads(vMensaje)
        vMethod = vJSON.get("method")
        vID = vJSON.get("id")

        print(f"[MCP] Petición recibida: {vMethod}")

        if vMethod == "tools/list":
          vRespuesta = {
            "jsonrpc": "2.0",
            "id": vID,
            "result": {
              "tools": [
                {"name": "port.scan"},
                {"name": "service.enum"},
                {"name": "vuln.scan"},
                {"name": "network.sniff"},
                {"name": "report.write"},
                {"name": "report.final_md"},
                {"name": "report.final_html"},
                {"name": "exploit.write_poc"},
                {"name": "exploit.run"}
              ]
            }
          }
          await vWS.send(json.dumps(vRespuesta))
          continue

        if vMethod == "tools/call":
          vTool = vJSON["params"]["tool"]
          vArgs = vJSON["params"]["arguments"]

          print(f"[MCP] Ejecutando herramienta: {vTool}")

          vOutput = {}

          try:
            if vTool == "port.scan":
              vOutput = fPortScan(
                vArgs.get("target"),
                vArgs.get("ports"),
                vArgs.get("scan_type"),
                vArgs.get("workspace")
              )

            elif vTool == "service.enum":
              vOutput = fServiceEnum(
                vArgs.get("target"),
                vArgs.get("ports"),
                vArgs.get("workspace")
              )

            elif vTool == "vuln.scan":
              vOutput = fVulnScan(
                vArgs.get("target"),
                vArgs.get("workspace")
              )

            elif vTool == "network.sniff":
              vOutput = fNetworkSniff(
                vArgs.get("interface"),
                vArgs.get("count"),
                vArgs.get("filter"),
                vArgs.get("workspace")
              )

            elif vTool == "report.write":
              vOutput = fReportWrite(vArgs["workspace"], vArgs["section"], vArgs["content"])

            elif vTool == "report.final_md":
              vOutput = fReportFinalMD(vArgs["workspace"], vArgs["content"])

            elif vTool == "report.final_html":
              vOutput = fReportFinalHTML(vArgs["workspace"], vArgs["content"])

            elif vTool == "exploit.write_poc":
              vOutput = fExploitWritePoC(vArgs["workspace"], vArgs["filename"], vArgs["content"])

            elif vTool == "exploit.run":
              vOutput = fExploitRun(vArgs["workspace"], vArgs["filename"], vArgs.get("args"))

            else:
              vOutput = {"error": f"Herramienta desconocida: {vTool}"}

          except Exception as e:
            print(f"[MCP] ERROR al ejecutar {vTool}: {e}")
            import traceback
            traceback.print_exc()
            vOutput = {"error": f"Error ejecutando {vTool}: {str(e)}"}

          # Enviar respuesta
          vRespuesta = {
            "jsonrpc": "2.0",
            "id": vID,
            "result": {"output": vOutput}
          }
          await vWS.send(json.dumps(vRespuesta))
          continue

      except Exception as e:
        print(f"[MCP] ERROR procesando mensaje: {e}")
        import traceback
        traceback.print_exc()
        # Intentar enviar error al cliente
        try:
          vErrorResp = {
            "jsonrpc": "2.0",
            "id": vJSON.get("id") if 'vJSON' in locals() else None,
            "error": {"code": -32603, "message": str(e)}
          }
          await vWS.send(json.dumps(vErrorResp))
        except:
          pass

  except Exception as e:
    print(f"[MCP] ERROR en conexión: {e}")
    import traceback
    traceback.print_exc()


# --------------------------------------------------------
# MAIN SERVER
# --------------------------------------------------------

async def main():
  print(f"\n{'='*60}")
  print(f"MCP LAN Pentesting Server")
  print(f"{'='*60}")
  print(f"Escuchando en: ws://{vHost}:{vPort}")
  print(f"Estado: ACTIVO")
  print(f"{'='*60}\n")
  print("Esperando conexiones...\n")

  async with websockets.serve(fHandle, vHost, vPort):
    await asyncio.Future()

if __name__ == "__main__":
  asyncio.run(main())
