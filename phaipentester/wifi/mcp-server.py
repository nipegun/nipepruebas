#!/usr/bin/env python3

import importlib
import subprocess
import sys
import asyncio
import json
import websockets
import time
import os
import shutil
import shlex
import stat
import signal

# --------------------------------------------------------
# CONFIG
# --------------------------------------------------------

vHost = "127.0.0.1"
vPort = 9005 # Puertos: ad(9001), bt(9002), lan(9003), web(9004), wifi(9005)

# --------------------------------------------------------
# CMDHISTORY - Contador global
# --------------------------------------------------------

vCmdCounter = 0

# --------------------------------------------------------
# HELPERS GENERALES
# --------------------------------------------------------

def fEjecutarComando(vCmd, vWorkspace=None):
  global vCmdCounter
  try:
    # Si tenemos workspace, crear cmdhistory ahí; si no, en carpeta del framework
    if vWorkspace:
      vCmdHistoryDir = os.path.join(vWorkspace, "cmdhistory")
    else:
      vCmdHistoryDir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "cmdhistory")

    os.makedirs(vCmdHistoryDir, exist_ok=True)

    # Incrementar contador
    vCmdCounter += 1
    vNumStr = str(vCmdCounter).zfill(3)

    # Guardar comando (input)
    vInFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-in.txt")
    with open(vInFile, "w") as f:
      f.write(vCmd)

    print(f"[CMD] Ejecutando: {vCmd}")
    v = subprocess.run(vCmd, shell=True, capture_output=True, text=True)
    vSalida = v.stdout + "\n" + v.stderr

    # Guardar salida (output)
    vOutFile = os.path.join(vCmdHistoryDir, f"{vNumStr}-out.txt")
    with open(vOutFile, "w") as f:
      f.write(vSalida)

    return vSalida
  except Exception as e:
    return str(e)

def fAsegurarHerramienta(vNombre):
  if not shutil.which(vNombre):
    return False
  return True

# --------------------------------------------------------
# HERRAMIENTAS WIRELESS
# --------------------------------------------------------

def fWifiScanInterface(vInterface, vAction, vWorkspace):
  if not fAsegurarHerramienta("airmon-ng"):
    return "ERROR: airmon-ng no encontrado. Instala aircrack-ng."
  
  vAction = vAction or "check"
  
  if vAction == "start":
    vCmd = f"sudo airmon-ng start {shlex.quote(vInterface)}"
    vMsg = "Iniciando modo monitor..."
  elif vAction == "stop":
    vCmd = f"sudo airmon-ng stop {shlex.quote(vInterface)}"
    vMsg = "Deteniendo modo monitor..."
  else:
    vCmd = "sudo airmon-ng"
    vMsg = "Verificando interfaces..."

  vSalida = fEjecutarComando(vCmd, vWorkspace)
  return f"{vMsg}\n{vSalida}"

def fWifiScanNetworks(vInterface, vDuration, vWorkspace):
  if not fAsegurarHerramienta("airodump-ng"):
    return "ERROR: airodump-ng no encontrado."

  vSalidaCSV = os.path.join(vWorkspace, "evidence", f"airodump_scan_{int(time.time())}")
  os.makedirs(os.path.dirname(vSalidaCSV), exist_ok=True)

  vDuration = int(vDuration) if vDuration else 15
  vInterface = vInterface or "wlan0mon"

  # airodump-ng no termina solo fácilmente con timeout en subprocess.Run si tiene output interactivo.
  # Usamos timeout command de linux.
  vCmd = f"sudo timeout {vDuration} airodump-ng -w {shlex.quote(vSalidaCSV)} --output-format csv {shlex.quote(vInterface)}"

  vSalida = fEjecutarComando(vCmd, vWorkspace)

  # Leemos el CSV generado para devolver resultados estructurados si es posible, o al menos el texto
  vFileCSV = vSalidaCSV + "-01.csv"
  if os.path.exists(vFileCSV):
    try:
      with open(vFileCSV, "r", encoding="utf-8", errors="replace") as f:
        vContenido = f.read()
      return f"Escaneo finalizado. Archivo guardado: {vFileCSV}\n\nCONTENIDO CSV:\n{vContenido}"
    except Exception as e:
      return f"Escaneo finalizado pero error al leer CSV: {e}"
  
  return f"Escaneo finalizado. No se generó archivo CSV. Salida:\n{vSalida}"

def fWifiCaptureHandshake(vInterface, vBSSID, vChannel, vDuration, vWorkspace):
  if not fAsegurarHerramienta("airodump-ng"):
    return "ERROR: airodump-ng no encontrado."

  vSalidaBase = os.path.join(vWorkspace, "evidence", f"handshake_{vBSSID.replace(':','-')}_{int(time.time())}")
  os.makedirs(os.path.dirname(vSalidaBase), exist_ok=True)

  vDuration = int(vDuration) if vDuration else 60
  vInterface = vInterface or "wlan0mon"
  vChannel = vChannel or "1"

  vCmd = (
    f"sudo timeout {vDuration} airodump-ng "
    f"--bssid {shlex.quote(vBSSID)} "
    f"--channel {shlex.quote(vChannel)} "
    f"-w {shlex.quote(vSalidaBase)} "
    f"{shlex.quote(vInterface)}"
  )

  vSalida = fEjecutarComando(vCmd, vWorkspace)
  return f"Captura finalizada. Archivos guardados con prefijo: {vSalidaBase}\nVerifica si existe el .cap para cracking."

def fWifiDeauth(vInterface, vBSSID, vClient, vCount, vWorkspace):
  if not fAsegurarHerramienta("aireplay-ng"):
    return "ERROR: aireplay-ng no encontrado."

  vCount = vCount or "5"
  vClient = vClient or "FF:FF:FF:FF:FF:FF" # Broadcast si no se especifica
  vInterface = vInterface or "wlan0mon"
  
  vCmd = (
    f"sudo aireplay-ng --deauth {shlex.quote(str(vCount))} "
    f"-a {shlex.quote(vBSSID)} "
    f"-c {shlex.quote(vClient)} "
    f"{shlex.quote(vInterface)}"
  )

  vSalida = fEjecutarComando(vCmd, vWorkspace)
  return vSalida

def fWifiCrack(vWorkspace, vPcapFile, vWordlist):
  if not fAsegurarHerramienta("aircrack-ng"):
    return "ERROR: aircrack-ng no encontrado."

  if not vWordlist:
    vWordlist = "/usr/share/wordlists/rockyou.txt"

  vCmd = f"aircrack-ng -w {shlex.quote(vWordlist)} {shlex.quote(vPcapFile)}"

  vSalida = fEjecutarComando(vCmd, vWorkspace)
  return vSalida


# --------------------------------------------------------
# REPORT (Reutilizados)
# --------------------------------------------------------

def fReportWrite(vWorkspace, vSection, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  vLinea = f"\n=== {vSection} ===\n{vContent}\n"
  with open(vReportFile, "a") as f:
    f.write(vLinea)
  return {"status": "ok", "written": vLinea}

def fFindingReport(vWorkspace, vTitle, vSeverity, vDescription, vEvidence, vRecommendation):
  """
  Reporta un hallazgo estructurado en findings.txt

  Args:
    vWorkspace: Ruta al workspace
    vTitle: Título del hallazgo
    vSeverity: Severidad (Critical, High, Medium, Low, Info)
    vDescription: Descripción del hallazgo
    vEvidence: Evidencia técnica
    vRecommendation: Recomendación de remediación
  """
  vReportFile = os.path.join(vWorkspace, "report", "findings.txt")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)

  vTimestamp = time.strftime('%Y-%m-%d %H:%M:%S')
  vSeverity = vSeverity or "Info"
  vDescription = vDescription or "Sin descripción"
  vEvidence = vEvidence or "Sin evidencia"
  vRecommendation = vRecommendation or "Sin recomendación"

  vFinding = f"""
{'='*70}
[HALLAZGO] {vTitle}
{'='*70}
Fecha/Hora: {vTimestamp}
Severidad:  {vSeverity}

DESCRIPCIÓN:
{vDescription}

EVIDENCIA:
{vEvidence}

RECOMENDACIÓN:
{vRecommendation}
{'='*70}

"""

  with open(vReportFile, "a") as f:
    f.write(vFinding)

  return {
    "status": "ok",
    "message": "Hallazgo reportado exitosamente",
    "severity": vSeverity,
    "title": vTitle,
    "file": vReportFile
  }

def fReportFinalMD(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.md")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}

def fReportFinalHTML(vWorkspace, vContent):
  vReportFile = os.path.join(vWorkspace, "report", "final.html")
  os.makedirs(os.path.dirname(vReportFile), exist_ok=True)
  with open(vReportFile, "w") as f:
    f.write(vContent)
  return {"status": "ok", "path": vReportFile}


# --------------------------------------------------------
# MANEJO DE SOLICITUDES MCP
# --------------------------------------------------------

async def fHandle(vWS):
  print(f"[MCP] Nueva conexión establecida desde {vWS.remote_address}")

  async for vMensaje in vWS:
    vJSON = json.loads(vMensaje)
    vMethod = vJSON.get("method")
    vID = vJSON.get("id")

    print(f"[MCP] Petición recibida: {vMethod}")

    if vMethod == "tools/list":
      vRespuesta = {
        "jsonrpc": "2.0",
        "id": vID,
        "result": {
          "tools": [
            {"name": "wifi.scan_interface"},
            {"name": "wifi.scan_networks"},
            {"name": "wifi.capture_handshake"},
            {"name": "wifi.deauth"},
            {"name": "wifi.crack"},
            {"name": "finding.report"},
            {"name": "report.write"},
            {"name": "report.final_md"},
            {"name": "report.final_html"}
          ]
        }
      }
      await vWS.send(json.dumps(vRespuesta, ensure_ascii=False))
      continue

    if vMethod == "tools/call":
      vTool = vJSON["params"]["tool"]
      vArgs = vJSON["params"]["arguments"]

      print(f"[MCP] Ejecutando herramienta: {vTool}")

      vOutput = {}

      if vTool == "wifi.scan_interface":
        vOutput = fWifiScanInterface(
          vArgs.get("interface"), 
          vArgs.get("action"), 
          vArgs.get("workspace")
        )

      elif vTool == "wifi.scan_networks":
        vOutput = fWifiScanNetworks(
          vArgs.get("interface"), 
          vArgs.get("duration"), 
          vArgs.get("workspace")
        )

      elif vTool == "wifi.capture_handshake":
        vOutput = fWifiCaptureHandshake(
          vArgs.get("interface"), 
          vArgs.get("bssid"), 
          vArgs.get("channel"), 
          vArgs.get("duration"), 
          vArgs.get("workspace")
        )

      elif vTool == "wifi.deauth":
        vOutput = fWifiDeauth(
          vArgs.get("interface"), 
          vArgs.get("bssid"), 
          vArgs.get("client"), 
          vArgs.get("count"), 
          vArgs.get("workspace")
        )

      elif vTool == "wifi.crack":
        vOutput = fWifiCrack(
          vArgs.get("workspace"), 
          vArgs.get("pcap_file"), 
          vArgs.get("wordlist")
        )

      elif vTool == "finding.report":
        vOutput = fFindingReport(
          vArgs["workspace"],
          vArgs["title"],
          vArgs.get("severity", "Info"),
          vArgs.get("description", ""),
          vArgs.get("evidence", ""),
          vArgs.get("recommendation", "")
        )

      elif vTool == "report.write":
        vOutput = fReportWrite(vArgs["workspace"], vArgs["section"], vArgs["content"])

      elif vTool == "report.final_md":
        vOutput = fReportFinalMD(vArgs["workspace"], vArgs["content"])

      elif vTool == "report.final_html":
        vOutput = fReportFinalHTML(vArgs["workspace"], vArgs["content"])

      # Enviar respuesta
      vRespuesta = {
        "jsonrpc": "2.0",
        "id": vID,
        "result": {"output": vOutput}
      }
      await vWS.send(json.dumps(vRespuesta, ensure_ascii=False))
      continue


# --------------------------------------------------------
# MAIN SERVER
# --------------------------------------------------------

async def main():
  print(f"\n{'='*60}")
  print(f"MCP WIFI Pentesting Server")
  print(f"{'='*60}")
  print(f"Escuchando en: ws://{vHost}:{vPort}")
  print(f"Estado: ACTIVO")
  print(f"{'='*60}\n")
  print("Esperando conexiones...\n")

  async with websockets.serve(fHandle, vHost, vPort):
    await asyncio.Future()

if __name__ == "__main__":
  asyncio.run(main())
